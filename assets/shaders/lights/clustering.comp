#version 450
layout(local_size_x = 4, local_size_y = 4, local_size_z = 4) in;

layout(rgba32ui, set = 0, binding = 0) uniform writeonly uimage3D uCluster;
#ifdef INHERIT
layout(set = 0, binding = 1) uniform usampler3D uClusterInherit;
#endif

struct LightInfo
{
	vec3 color;
	float spot_outer;

	vec3 falloff;
	float inv_radius;

	vec3 position;
	float spot_inner;

	vec3 direction;
	float angle;
};

layout(std140, set = 1, binding = 0) uniform SpotLight
{
    LightInfo lights[32];
} spot;

layout(std140, set = 1, binding = 1) uniform PointLight
{
    LightInfo lights[32];
} point;

layout(std430, push_constant) uniform Registers
{
    mat4 inv_cluster_transform;
    ivec4 size;
    vec3 inv_texture_size;
    vec3 inv_size;
    float cube_radius;
    uint spot_count;
    uint point_count;
    int z_offset;
} registers;

void main()
{
    ivec3 id = ivec3(gl_GlobalInvocationID.xyz);
    if (any(greaterThanEqual(id, registers.size.xyz)))
        return;

    uint point_mask = 0u;
    uint spot_mask = 0u;

#ifdef INHERIT
    uvec2 bits = textureLod(uClusterInherit, (vec3(id + ivec3(0, 0, registers.z_offset)) + 0.5) * registers.inv_texture_size, 0.0).xy;
#else
    uint num_spot = registers.spot_count;
    uint num_point = registers.point_count;
#endif

    vec3 cube_center = (registers.inv_cluster_transform * vec4(vec3(2.0, 2.0, 1.0) * (vec3(id) + 0.5) * registers.inv_size - vec3(1.0, 1.0, 0.0), 1.0)).xyz;
    float cube_radius = registers.cube_radius;

#ifdef INHERIT
    while (bits.x != 0u)
#else
    for (uint i = 0u; i < num_spot; i++)
#endif
    {
#ifdef INHERIT
        uint i = uint(findLSB(bits.x));
#endif
        vec3 center = spot.lights[i].position;
        vec3 direction = spot.lights[i].direction;
        float size = 1.0 / spot.lights[i].inv_radius;
        float angle = spot.lights[i].angle;

        // Sphere/cone culling from https://bartwronski.com/2017/04/13/cull-that-cone/.
        vec3 V = cube_center - center;
        float V_sq = dot(V, V);
        float V1_len  = dot(V, direction);
        float V2_len = sqrt(max(V_sq - V1_len * V1_len, 0.0));
        float distance_closest_point = cos(angle) * V2_len - sin(angle) * V1_len;

        if (!any(greaterThan(vec3(distance_closest_point, V1_len, -V1_len), vec3(cube_radius, cube_radius + size, cube_radius))))
            spot_mask |= 1u << i;
#ifdef INHERIT
        bits.x &= ~(1u << i);
#endif
    }

#ifdef INHERIT
    while (bits.y != 0u)
#else
    for (uint i = 0u; i < num_point; i++)
#endif
    {
#ifdef INHERIT
        uint i = uint(findLSB(bits.y));
#endif
        vec3 center = point.lights[i].position;
        float radius = 1.0 / point.lights[i].inv_radius;
        float radial_dist = distance(cube_center, center);
        bool radial_outside = radial_dist > (cube_radius + radius);

        if (!radial_outside)
            point_mask |= 1u << i;
#ifdef INHERIT
        bits.y &= ~(1u << i);
#endif
    }

    id.z += registers.z_offset;
    imageStore(uCluster, id, uvec4(spot_mask, point_mask, 0u, 0u));
}